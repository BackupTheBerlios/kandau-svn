<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC "-//KDE//DTD DocBook XML V4.1.2-Based Variant V1.1//EN" "dtd/kdex.dtd" [
  <!ENTITY kandau "<application>kandau 0&#46;1</application>">
  <!ENTITY kappname "&kandau;"><!-- Do *not* replace kappname-->
  <!ENTITY package "kde-module"><!-- kdebase, kdeadmin, etc -->
  <!ENTITY % addindex "IGNORE">
  <!ENTITY % English "INCLUDE"><!-- change language only here -->


  <!-- Do not define any other entities; instead, use the entities
       from kde-genent.entities and $LANG/user.entities. -->
]>
<!-- kdoctemplate v0.8 October 1 1999
     Minor update to "Credits and Licenses" section on August 24, 2000
     Removed "Revision history" section on 22 January 2001
     Changed to Installation/Help menu entities 18 October 2001
     Other minor cleanup and changes 18 October 2001 -->


<!--
This template was designed by: David Rugge davidrugge@mindspring.com
with lots of help from: Eric Bischoff ebisch@cybercable.tm.fr
and Frederik Fouvry fouvry@sfs.nphil.uni-tuebingen.de
of the KDE DocBook team.

You may freely use this template for writing any sort of KDE documentation.
If you have any changes or improvements, please let us know.

Remember:
- in XML, the case of the <tags> and attributes is relevant ;
- also, quote all attributes.

Please don't forget to remove all these comments in your final documentation,
thanks ;-).
-->

<!-- ................................................................ -->

<!-- The language must NOT be changed here. -->

<book lang="&language;">

<!-- This header contains all of the meta-information for the document such
as Authors, publish date, the abstract, and Keywords -->

<bookinfo>
<title>The &kandau; Handbook</title>

<authorgroup>
<author>
<firstname></firstname>
<othername></othername>
<surname>Albert Cervera Areny</surname>
<affiliation>
<address><email>albertca&#64;hotpop&#46;com</email></address>
</affiliation>
</author>
</authorgroup>

<!-- TRANS:ROLES_OF_TRANSLATORS -->

<copyright>
<year>2005</year>
<holder>Albert Cervera Areny</holder>
</copyright>
<!-- Translators: put here the copyright notice of the translation -->
<!-- Put here the FDL notice.  Read the explanation in fdl-notice.docbook
     and in the FDL itself on how to use it. -->
<legalnotice>&FDLNotice;</legalnotice>

<!-- Date and version information of the documentation
Don't forget to include this last date and this last revision number, we
need them for translation coordination !
Please respect the format of the date (YYYY-MM-DD) and of the version
(V.MM.LL), it could be used by automation scripts.
Do NOT change these in the translation. -->

<date>2005-10-14</date>
<releaseinfo>0&#46;1</releaseinfo>

<!-- Abstract about this handbook -->

<abstract>
<para>
&kandau; is transaction based backend independent object persistency framework for applications using the KDE libraries.
</para>
</abstract>

<!-- This is a set of Keywords for indexing by search engines.
Please at least include KDE, the KDE package it is in, the name
 of your application, and a few relevant keywords. -->

<keywordset>
<keyword>KDE</keyword>
<keyword>kandau</keyword>
<keyword>persistency</keyword>
<keyword>object</keyword>
</keywordset>

</bookinfo>

<!-- The contents of the documentation begin here.  Label
each chapter so with the id attribute. This is necessary for two reasons: it
allows you to easily reference the chapter from other chapters of your
document, and if there is no ID, the name of the generated HTML files will vary
from time to time making it hard to manage for maintainers and for the CVS
system. Any chapter labelled (OPTIONAL) may be left out at the author's
discretion. Other chapters should not be left out in order to maintain a
consistent documentation style across all KDE apps. -->

<chapter id="introduction">
<title>Introduction</title>

<para>
&kandau; is a library which offers an easy way to save C++ objects into whatever backend you can imagine. Currently implemented are the SQL and XML backends.

You can find up to date information at <ulink url="http://developer.berlios.de/projects/kandau"/>
</para>

<para>
Here is a list of &kandau; features:
</para>

<itemizedlist>
	<listitem><para><emphasis>Object manager.</emphasis> Object pointers are managed by the library making it harder to leak objects in memory.</para></listitem>
	<listitem><para><emphasis>Class introspection.</emphasis> Offers an easy way to browse all the classes, its properties, relations and associated metadata without a precompiler. Only inherit and call a couple of macros.</para></listitem>
	<listitem><para><emphasis>Dynamic classes.</emphasis> Apart from the classes created by the programmer, new classes can be created at run time. This classes, can have relations with C++ ones and use the same persistency framework.</para></listitem>
	<listitem><para><emphasis>Read only properties.</emphasis>Read only properties can be created so they are browsable but not saved at commit time.</para></listitem>
	<listitem><para><emphasis>QObject properties compatible.</emphasis> Though an alternative iterator is provided for easy object introspection, &kandau; uses the same property system provided by Qt, so no functionality is lost by making the object persistent.</para></listitem>
	<listitem><para><emphasis>Notification system.</emphasis>A notification system is provided so a slot can be registered to be notified each time an object, any object in a class or a particular property is modified.</para></listitem>
	<listitem><para><emphasis>Caching system.</emphasis> In some backends, you can configure the maximum number of objects that are kept in memory by the manager, so they don't have to be loaded from the database/backend.</para></listitem>
	<listitem><para><emphasis>Transaction based.</emphasis>All modifications should be commited or rolledback. No saving is done until the <function>commit()</function> function is called.</para></listitem>
	<listitem><para><emphasis>Backend independent.</emphasis>You can make your program without worrying where your data will be saved. Currently, SQL, XML and .desktop backends are implemented, but you can create your own.</para></listitem>
	<listitem><para><emphasis>DCOP interface.</emphasis> &kandau; comes with some tests and demo applications. A nice one is a DCOP Server. Use this application with a library which has implemented all your persistent classes and you immediately have a simple way to save and load data using shell scripts and without the need to treat xml files or know the structure of your sql database.</para></listitem>
	<listitem><para><emphasis>Automatic relationship updates.</emphasis>Say you have object A, and object B. Say you set the relation <emphasis>brother</emphasis> of object A to <emphasis>B</emphasis>. Then you query B to know who is <emphasis>brother</emphasis> and it will tell you it is <emphasis>A</emphasis></para></listitem>
	<listitem><para><emphasis>Multiple backends simultaneously.</emphasis>You can have objects pertaining to different backends at the same time, two configuration files, for example.</para></listitem>
</itemizedlist>

<para>Another good way to know what is the status of an application is to know what's missing or not working. So here is a list of TODOs:</para>

<itemizedlist>
	<listitem><para><emphasis>Querying system.</emphasis> A way to query the objects, OQL or something like that is needed. The only thing done at the moment is allowing for dot notation in SQL queries to the SQL backend. This has two problems: It's backend dependent and only returns objects which have already been commited to the database.</para></listitem>
	<listitem><para><emphasis>JDO files support.</emphasis> It'd be nice to have an SQL backend which honours the mapping of properties/fields from objects to database of a JDO file.</para></listitem>
	<listitem><para><emphasis>Support 1-1 relations of objects of the same class.</emphasis> Because of the object relations automatic consistency system, 1-1 relations of objects of the same class has some problems, so it is not possible to make object A point to B and B point to C if all are of the same class.
	</para></listitem>
	<listitem><para><emphasis>General testing and bugfixing.</emphasis> The most applications use the better tested. At the moment there are unit tests only, which test specific parts of the library, but probably some cases are left without testing.</para></listitem>
	<listitem><para>Some class names are too general and would need some prefix or be included inside a namespace.</para></listitem>
	<listitem><para><emphasis>Add support for extra checks on commit.</emphasis> For example, don't allow null values, ensure unique values, etc. Everything should be specified in the class' declaration or implementation.</para></listitem>
</itemizedlist>

</chapter>


<chapter id="using-kandau">
<title>Using &kandau;</title>

<para>
In this chapter you'll have detailed information on how you can use the kandau framework for your application so you can create persistent objects.
</para>


<sect1 id="prepare_class">
<title>Prepare a class for persistency</title>

<para>The first thing we will have to do is let the persistency manager know that one of your classes can be persistent. That's what we'll do in this section.</para>

<para>So to start we need an object. Here is what you would declare if you used the Qt library:</para>

<programlisting>
<![CDATA[
#include <qobject.h>

class Book : public QObject
{
	Q_OBJECT
	Q_PROPERTY( QString title READ title WRITE setTitle )
	Q_PROPERTY( QString author READ author WRITE setAuthor )
	Q_PROPERTY( QString isbn READ isbn WRITE setIsbn )
	Q_PROPERTY( uint year READ year WRITE setYear )
public:
	void setTitle( const QString& title );
	const QString& title() const;

	void setAuthor( const QString& author );
	const QString& author() const;

	void setIsbn( const QString& isbn );
	const QString& isbn() const;

	void setYear( uint year );
	const uint year() const;

private:
	QString m_title;
	QString m_author;
	QString m_isbn;
	uint m_year;
};
]]>
</programlisting>

<para>
So what we have here is a Book class declaration. A book has four properties: title, author, isbn and year. The implementation details are obvious and so, are not shown.
</para>

<note>
<para>If you're unfamiliar with the Q_PROPERTY thing, please take a look at how properties work with the Qt library at <ulink url="http://doc.trolltech.com/3.3/properties.html"/></para>
</note>

<para>
The next step will be to allow our Book objects to be persistent using the &kandau; framework. So here is how our header file should look like:
</para>

<programlisting>
<![CDATA[
#include <object.h>

class Book : public Object
{
	Q_OBJECT
	Q_PROPERTY( QString title READ title WRITE setTitle )
	Q_PROPERTY( QString author READ author WRITE setAuthor )
	Q_PROPERTY( QString isbn READ isbn WRITE setIsbn )
	Q_PROPERTY( uint year READ year WRITE setYear )
public:
	DCLASS( Book );

	void setTitle( const QString& title );
	const QString& title() const;

	void setAuthor( const QString& author );
	const QString& author() const;

	void setIsbn( const QString& isbn );
	const QString& isbn() const;

	void setYear( uint year );
	const uint year() const;

private:
	QString m_title;
	QString m_author;
	QString m_isbn;
	uint m_year;
};
]]>
</programlisting>

<para>
The .cpp file:
</para>

<programlisting>
<![CDATA[
#include "book.h"

ICLASS( Book );

void Book::createRelations()
{}

void Book::setTitle( const QString& title )
{
	m_title = title;
}
const QString& Book::title() const
{
	return m_title;
}

void Book::setAuthor( const QString& author )
{
	m_author = author;
}
const QString& Book::author() const
{
	return m_author;
}

void Book::setIsbn( const QString& isbn )
{
	m_isbn = isbn;
}
const QString& Book::isbn() const
{
	return m_isbn;
}

void Book::setYear( uint year )
{
	m_year = year;
}
uint Book::year() const
{
	return m_year;
}
]]>
</programlisting>

<para>
And that's all. Now we're able to store any book object into a PostgreSQL database or an XML file without writting any serialization code. Does that sound good to you? If so, look at the changes we've made with respect the original Qt implementation:
<itemizedlist>
	<listitem><para>Inherit from Object instead of QObject.</para></listitem>
	<listitem><para>Add a call to the DCLASS( your_class ) macro in the header file.</para></listitem>
	<listitem><para>Add a call to the ICLASS( your_class ) macro in the implementation file.</para></listitem>
	<listitem><para>Add the implementation of the createRelations function (which is empty in this example).</para></listitem>
</itemizedlist>

</para>
</sect1>


<sect1 id="initialization">
<title>Initialization</title>

<para>Once we have created all the classes, we need to initialize the system.</para>
<para>First of all, we have to call the Classes::setup() static function. That should be done at the very beggining. After that call, you can start browsing all the available classes. See the Classes class for more information on that.</para>

<para>After that, most usually you'll want to initialize the Manager. Here is where you decide which backend you want.
</para>

<para>Here is an example on how to initialize the SQL Backend.</para>

<programlisting>
<![CDATA[
#include <kdebug.h>

#include <qsqldatabase.h>

#include <classes.h>
#include <manager.h>
#include <sqldbbackend.h>

int main()
{
	Classes::setup();
	QSqlDatabase *db = QSqlDatabase::addDatabase( "QPSQL7" );
	db->setDatabaseName( "bookshelf" );
	db->setUserName( "user" );
	db->setPassword( "password" );
	db->setHostName( "localhost" );
	if ( ! db->open() ) {
		kdDebug() << "Failed to open database: " << db->lastError().text() << endl;
		return 1;
	}
	DbBackendIface *backend = new SqlDbBackend( db );
	Manager *manager = new Manager( backend );

	// Your stuff here

	delete manager;
}
]]>
</programlisting>

<note><para>The database needs to exist, but you can optionally call m_manager->createSchema() function, which will create the table book in your database.</para></note>

<para>To use the XML backend, you can use something like this:</para>

<programlisting>
<![CDATA[
	DbBackendIface *backend = new XmlDbBackend( "bookshelf.xml" );
	Manager *manager = new Manager( backend );
]]>
</programlisting>

<note><para>You can instantiate as many managers as you want, the last one you create will become the default Manager and will be available with the Manager::self() static function.</para></note>

</sect1>

<sect1 id="storing">
<title>Storing and removing objects</title>
<para>Now that we have our classes and the engine initialized, we can start creating, storing and removing objects. Look at the example below:</para>

<programlisting>
<![CDATA[
ObjectRef<Book> benzina = Book::create();
benzina->setTitle( "Benzina" );
benzina->setAuthor( "Quim Monzó" );
benzina->setIsbn( "84-7727-434-7" );
benzina->setYear( 1983 );

ObjectRef<Book> sentimental = Book::create();
sentimental->setTitle( "Sentimental" );
sentimental->setAuthor( "Sergi PÃÂ mies" );
sentimental->setIsbn( "84-7727-135-6" );
sentimental->setYear( 1995 );
Manager::self()->commit();

Manager::self()->remove( sentimental );
Manager::self()->rollback();

kdDebug() << "Sergi Pàmies' book title: " << sentimental->title() << endl;
]]>
</programlisting>

<para>Some notes about the code above:</para>

<itemizedlist>
	<listitem><para>The first thing we do is create an object which is automatically managed by the Manager class. That's why we call Book::create() instead of using the <emphasis>new</emphasis> operator.
	</para></listitem>
	<listitem><para>Note that we use the ObjectRef template instead of using a Book pointer directly. This is good practice, as once the object has been commited the instance in memory could be freed. The template will ensure that it will be loaded any time you try to access any property once commited.</para></listitem>
</itemizedlist>

</sect1>

<sect1 id="loading">
<title>Loading objects</title>
<para>There are mainly three ways you can use to load objects:</para>
<itemizedlist>
	<listitem><para>When you have an object loaded that points to another one. If the latter isn't loaded, it will be loaded automatically by the engine.</para></listitem>
	<listitem><para>You can load a random object by its oid.</para></listitem>
	<listitem><para>Load a collection of objects of the same class.</para></listitem>
</itemizedlist>

<para>The first one will be analyzed later in this chapter.</para>

<para>See in the following listing an example of the second method:</para>
<programlisting>
<![CDATA[
ObjectRef<Book> benzina = Book::create( 1 );
if ( ! benzina.isNull() ) {
	kdDebug() << "Author: " << benzina->author() << endl;
}
]]>
</programlisting>

<para>And here an example of the third method:</para>

<programlisting>
<![CDATA[
Collection books( "Book" );
Book *book;
CollectionIterator it( books.begin() );
CollectionIterator end( books.end() );
for ( ; it != end; ++it ) {
	book = static_cast<Book*>( *it );
	kdDebug() << "Title: " << book->title() << endl;
}
]]>
</programlisting>

</sect1>

<sect1 id="multiple_managers">
<title>Using multiple managers simultaneously</title>

<para>Until the moment we have supposed that we only created one manager. However &kandau; allows you to create multiple managers, with different backends. Let me show you a simple example on how you would work in that case:</para>

<programlisting>
<![CDATA[
DbBackendIface *backendA = new XmlDbBackend( "bookshelf.xml" );
managerA = new Manager( backendA );
DbBackendIface *backendB = new XmlDbBackend( "library.xml" );
managerB = new Manager( backendB );

// Load an object by its oid from "bookshelf.xml"
ObjectRef<Book> benzina = Book::create( 1, managerA );
if ( ! benzina.isNull() ) {
	// If the object exists copy it to "library.xml"
	ObjectRef<Book> benzinaCopy = Book::create( managerB );
	benzinaCopy->setTitle( benzina->title() );
	benzinaCopy->setAuthor( benzina->author() );
	benzinaCopy->setIsbn( benzina->isbn() );
	benzinaCopy->setYear( benzina->year() );
	managerB->commit();
}
]]>
</programlisting>
</sect1>

<sect1 id="relations">
<title>Working with relations</title>
<para>By now, our example has been quite limited, as we only talked about a single class. But real world applications don't consist of separate classes but they relate to each other. In our example, we could have the same author for many books, and we could be interested in his/her biography, for example:</para>

<programlisting>
<![CDATA[
class Author : public Object
{
	Q_OBJECT
	Q_PROPERTY( QString firstName READ firstName WRITE setFirstName );
	Q_PROPERTY( QString lastName READ lastName WRITE setLastName );
	Q_PROPERTY( QString fullName READ fullName );
	Q_PROPERTY( QString biography READ biography WRITE setBiography );
	Q_PROPERTY( uint birthYear READ birthYear WRITE setBirthYear );

public:
	DCLASS( Author );

	void setFirstName( const QString& name );
	const QString& firstName() const;

	void setLastName( const QString& name );
	const QString& lastName() const;

	QString fullName() const;

	void setBiography( const QString& name );
	const QString& biography() const;

	void setBirthYear( uint year );
	uint birthYear() const;

	Collection* bibliography();

private:
	QString m_firstName;
	QString m_lastName;
	QString m_biography;
	uint m_birthYear;
};
]]>
</programlisting>

<para>As you can see, we have created the Author class, which has the first and last name, the biography and birth year of the author. A part from that we see two new things:</para>

<itemizedlist>
	<listitem><para>fullName is a read only property. Kandau will let you browse this property as any other, but the backend won't save that information in the database. In this case fullName simply concatenates the first and last names with a colon in between (e.g. "Monzó, Quim").</para></listitem>
	<listitem><para>bibliography is not a property. In fact we expect each book to have an author related, so it is possible to browse from the book to its author, but also the other way round. From the author get a list of all his/her books.</para></listitem>
</itemizedlist>

<para>Now that we have defined what information we want from the author, let's see what we need to change from the Book class. See the new Book declaration:</para>

<programlisting>
<![CDATA[
#include <object.h>

#include "author.h"

class Book : public Object
{
	Q_OBJECT
	Q_PROPERTY( QString title READ title WRITE setTitle )
	Q_PROPERTY( QString isbn READ isbn WRITE setIsbn )
	Q_PROPERTY( uint year READ year WRITE setYear )
public:
	DCLASS( Book );

	void setTitle( const QString& title );
	const QString& title() const;

	void setIsbn( const QString& isbn );
	const QString& isbn() const;

	void setYear( uint year );
	const uint year() const;

	void setAuthor( Author *author );
	Author* author() const;

private:
	QString m_title;
	QString m_isbn;
	uint m_year;
};
]]>
</programlisting>

<para>Nothing spectacular. Only note that we don't have to declare a private variable to hold the Author pointer. Relations between objects are also hold internally by the manager.</para>

<para>Now, we only need to know how to implement the setAuthor, author and bibliography functions. However, we must also fill in the createRelations() function that all Object classes need to have:</para>

<programlisting>
<![CDATA[
void Book::createRelations()
{
	OBJECT( Author );
}

void Book::setAuthor( Author *author )
{
	SETOBJECT( Author, author );
}

void Book::author() const
{
	return GETOBJECT( Author );
}
]]>
</programlisting>

<programlisting>
<![CDATA[
void Author::createRelations()
{
	COLLECTION( Book );
}

Collection* Author::bibliography()
{
	GETCOLLECTION( Book );
}
]]>
</programlisting>

<para>
That's it. After this change you can:
<itemizedlist>
	<listitem><para>Browse the Book and Author classes information and you will see that there exists a relation between them. Look at the ClassInfo API for more information.</para></listitem>
	<listitem><para>Use the setAuthor function to specify the author of a Book, and immediatly after see the book appended to the author's bibliography.</para></listitem>
	<listitem><para>Add the book to the author's bibliography, and immediatly after see the author of the book updated in the book object.</para></listitem>
</itemizedlist>
</para>

<programlisting>
<![CDATA[
ObjectRef<Author> monzo = Author::create();
monzo->setFirstName( "Quim" );
monzo->setLastName( "Monzó" );
monzo->setBirthYear( 1952 );
monzo->setBiography( "Born in Barcelona in 1952, has worked as a graphic designer, translator, journalist and has contributed to radio and TV programms." );

ObjectRef<Book> benzina = Book::create();
benzina->setTitle( "Benzina" );
benzina->setIsbn( "84-7727-434-7" );
benzina->setYear( 1983 );
monzo->bibliography()->add( benzina );

kdDebug() << "The author of the book 'Benzina' is " << benzina->author()->fullName() << endl;
// Output: "The author of the book 'Benzina' is Monzó, Quim"
]]>
</programlisting>

</sect1>

<sect1 id="browsing">
<title>Browse your classes</title>
<para>
As you may have already guessed, Kandau required macros build a graph in memory containing all your classes (ok, only those with the appropiate macros). That is used by the Kandau persistency engine, but is also available to the application developer and brings the possibilities of introspection beyond properties.
</para>
<para>
In fact, Qt's introspection works at Object level, while Kandau's works at class level, that is, you don't need to instantiate an object in order to know which properties the <emphasis>class</emphasis> has.
</para>
<para>
Some of the things that you can do are:
</para>
<itemizedlist>
	<listitem><para>Know which classes you have available.</para></listitem>
	<listitem><para>Instantiate an object by it's class name.</para></listitem>
	<listitem><para>Iterate through the properties of a class, its related objects and related collections (only those that are browsable from the class). Know the data types, whether they are readonly or not, etc.</para></listitem>
</itemizedlist>

<para>As allways an example makes it clearer. The following piece of code, iterates through all the existing classes and prints all their properties and type.</para>

<programlisting>
<![CDATA[
	ClassInfoIterator it( Classes::begin() );
	ClassInfoIterator end( Classes::end() );
	ClassInfo *info;
	for ( ; it != end; ++it ) {
		info = *it;
		kdDebug() << "Class: " << info->name() << endl;
		kdDebug() << "\tProperties:" << endl;
		PropertiesInfoConstIterator pit( info->propertiesBegin() );
		PropertiesInfoConstIterator pend( info->propertiesEnd() );
		PropertyInfo *pinfo;
		for ( ; pit != pend; ++pit ) {
			pinfo = *pit;
			kdDebug() << "\t\t" << pinfo->name() << " (" << QVariant::typeToName( pinfo->type() ) << ")" << endl;
		}
	}
]]>
</programlisting>

<para>
The output when you have declared the classes with which we've been working follows:
</para>

<programlisting>
<![CDATA[
Class: Author
        Properties:
                biography (QString)
                birthYear (uint)
                firstName (QString)
                fullName (QString)
                lastName (QString)
Class: Book
        Properties:
                isbn (QString)
                title (QString)
                year (uint)
]]>
</programlisting>

</sect1>

<sect1 id="metainfo">
<title>Adding meta information to your classes</title>
<para>
&kandau; offers you the possibility to add meta data to your classes. Similar in concept to the possibilities offered by the Qt framework, but this one allows you to relate a string to any object you want. The main difference, you don't declare meta information in the header but in the .cpp file. In the createRelations() function we've seen, so it's not very mysterious.
</para>

<para>
Following our books example, let's see how to add meta data:
</para>


<programlisting>
<![CDATA[
static const LabelDescription authorLabels[] = {
	{ "firstName", I18N_NOOP("First Name")},
	{ "lastName", I18N_NOOP("Last Name")},
	{ "fullName", I18N_NOOP("Full Name") },
	{ "biography", I18N_NOOP("Biography") },
	{ "birthYear", I18N_NOOP("Birth Year") },
	{ "bibliography", I18N_NOOP("Bibliography") },
	LabelDescriptionLast
};

void Author::createRelations()
{
	COLLECTION( Book );
	ADDMETAINFO( "labels", new LabelsMetaInfo( articleLabels ) );
}
]]>
</programlisting>

<para>
As you can see it's very simple. LabelsMetaInfo is a standard class that comes with Kandau and provides an easy way to relate the property name with an internationalizable string. Currently the only requirement for an object to be set as a metainfo value is that it must inherit QObject. That's all.
</para>

<para>
Now, you just need an easy way to acces meta data:
</para>

<programlisting>
<![CDATA[
QObject *meta = Classes::classInfo( "Author" )->metaInfo( "labels" );
if ( meta && meta->inherits( "LabelsMetaInfo" ) ) {
	LabelsMetaInfo *labels = static_cast<LabelsMetaInfo*>( meta );
	PropertiesInfoConstIterator pit( Classes::classInfo( "Author" )->propertiesBegin() );
	PropertiesInfoConstIterator pend( Classes::classInfo( "Author" )->propertiesEnd() );
	PropertyInfo *pinfo;
	for ( ; pit != pend; ++pit ) {
		pinfo = *pit;
		kdDebug() << "Property: " << pinfo->name() << ", Label: " << labels->label( pinfo->name() ) << endl;
	}
}
]]>
</programlisting>

<para>So the example, gets the QObject contained in the meta property "labels". Checks that the object exists and that it inherits "LabelsMetaInfo", and finally iterate through all the properties of the object and print their name and their i18n label.</para>

</sect1>

<sect1 id="dynamic">
<title>Dynamic Classes</title>
<para>
Dynamic classes are those who's structure can be configured at runtime and don't have a <emphasis>real</emphasis> C++ declaration. That is, you just create an structure which you want to be browseable just like any other class you have created, you want to be able to make it persistent with the same engine. But you can do more, you can relate these dynamic objects with your C++ ones and relations will be stored transparently for you.
</para>

<para>
As an example we will create a new class in our test application:
</para>

<programlisting>
<![CDATA[
Classes::addClass( "BookExtraInfo", DynamicObject::createInstance, 0 );
ClassInfo *ci = Classes::classInfo( "BookExtraInfo" );
ci->addProperty( "notes", QVariant::String );
ci->addProperty( "numberOfCopies", QVariant::ULongLong );
ci->addProperty( "dateOfAcquisition", QVariant::Date );
ci->addObject( "Book", "book" );
ci->addCollection( "Book", "similarBooks" );
]]>
</programlisting>

<para>
After the code is executed each time you browse your available classes you will have a new one called BookExtraInfo, which will contain three properties: notes, numberOfCopies and dateOfAcquisition, the book the information it relates to and a list of similar books. So if you are using the SQL backend and call the createSchema() function, you'll get two new tables (BookExtraInfo and similarBooks) with the necessary fields to store this information.
</para>

<para>Of course, you can create an instance of BookExtraInfo and set the dateOfAcquisition and a similar book with:</para>

<programlisting>
<![CDATA[
ObjectRef<Object> *obj = Classes::classInfo( "BookExtraInfo" )->create();
obj->setObject( "book", benzina );
obj->setProperty( "dateOfAcquisition", QDate::currentDate() );
obj->collection( "similarBooks" )->add( sentimental );
Manager::self()->commit();
]]>
</programlisting>

</sect1>

<sect1 id="notifications">
<title>Using the notification mechanism</title>
<para>
Another facility provided by &kandau; is a notification system. It allows you to register a slot to a concrete or general event. An event can be as concrete as <emphasis>property X has been modified in object Y</emphasis> or as general as <emphasis>something has been modified in class Z</emphasis> or even <emphasis>something has been modified</emphasis>.
</para>

<para>
This gives applications a powerful mechanism to update data in their GUI's without other explicit methods. See how you can register to a notification in the following example:
</para>

<programlisting>
<![CDATA[

]]>
</programlisting>



</sect1>



<sect1 id="dcop">
<title>Accessing your objects with Kandau &amp; DCOP</title>
<para>
<screenshot>
	<screeninfo>Here's a screenshot of &kandau;</screeninfo>
	<mediaobject>
		<imageobject>
			<imagedata fileref="kdcop.png" format="PNG"/>
		</imageobject>
		<textobject>
			<phrase>Screenshot</phrase>
		</textobject>
	</mediaobject>
</screenshot>

</para>
</sect1>

<sect1 id="performance">
<title>Performance Tips</title>

<para>
Kandau hasn't been tested for performance at the moment, and some of the mechanisms it uses would probably require that. However, the first thing to achieve is stability and features and performance enhancements will com later.
</para>

<para>
That said, I'd like to share some of the internal mechanisms that even before analyzing I think can cause performance problems to the users. So if you're worried about performance or your application suffers some of these problems I hope these notes will help you:
</para>

<sect2>
</sect2>

</sect1>

</chapter>


<chapter id="development">
	<title>Kandau development</title>
	<para>This chapter should describe Kandau internals. However, at the moment the best way to know about Kandau internals is the source code.</para>
</chapter>

<chapter id="distribution">
	<title>Kandau distribution files and applications</title>
	<para>This chapter describes the directory hierarchy of the Kandau distribution, some files and utilities.</para>

<sect1 id="hierarchy">
<title>Hierarchy</title>
<para>
</para>
</sect1>
</chapter>

<chapter id="developers">
<title>Developer's Guide to &kandau;</title>

<para>
Currently the best reference for &kandau; developers is the source code and the documentation generated by Doxygen. Though I intend to write and make some drawings of the architecture it'll have to wait a little bit.
</para>

</chapter>

<chapter id="faq">
<title>Questions and Answers</title>

<!--
&reporting.bugs;
&updating.documentation;
-->

<qandaset id="faqlist">
	<qandaentry>
		<question>
		<para>Is there a FAQ for &kandau;?</para>
		</question>
		<answer>
		<para>Congratulations! You found it ;)</para>
		</answer>
	</qandaentry>

</qandaset>
</chapter>

<chapter id="credits">

<!-- Include credits for the programmers, documentation writers, and
contributors here. The license for your software should then be included below
the credits with a reference to the appropriate license file included in the KDE
distribution. -->

<title>Credits and License</title>

<para>
&kandau;
</para>
<para>
Program copyright 2005 Albert Cervera Areny <email>albertca&#64;hotpop&#46;com</email>
</para>

<para>
Documentation copyright 2005 Albert Cervera Areny <email>albertca&#64;hotpop&#46;com</email>
</para>

<!-- TRANS:CREDIT_FOR_TRANSLATORS -->

&underFDL;

&underLGPL;

</chapter>

<appendix id="installation">
<title>Installation</title>

<sect1 id="getting-kandau">
<title>How to obtain &kandau;</title>

<para>The latest version of Kandau can be found at <ulink url="developer.berlios.de/projects/kandau"/></para>
</sect1>

<sect1 id="requirements">
<title>Requirements</title>

<para>
In order to use &kandau; you need Qt and KDE libraries. It's been tested with KDE 3.5 and Qt 3.3 though previous versions will probably work too. Note that you'll need the PostgreSQL support in Qt in order to use the SQL examples.
</para>

<para>
&kandau; can be found on <ulink url="http://developer.berlios.de/projects/kandau/">The &kandau; home page</ulink>
</para>
</sect1>

<sect1 id="compilation">
<title>Compilation and Installation</title>

&install.compile.documentation;

</sect1>

<!--
<sect1 id="configuration">
<title>Configuration</title>

<para>In order to use the SQL </para>

</sect1>
-->

</appendix>

&documentation.index;
</book>

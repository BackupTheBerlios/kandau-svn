
There are lots of things to think about. Here are some of them:

	(TEST) -> implemented but needs testing
	(PART) -> partially implemented
	(WORK) -> work in progress
	(DONE) -> mmm.. pretty obvious

(DONE)	- Load collections of objects. See below for extended/querying system.

(DONE)	- Save relations correctly in the SqlDbBackend::commit()

(PART)	- Create GOOD test cases for the different backends.

	- Improve DCOP interface

(DONE)	- Add the possibility to attach i18n() information to properties and
	relations 1-1 and 1-n and n-n. This shouldn't be too complex (with a
	simple approach, of course) but it is not a priority ATM. Maybe it has something to do with how other metadata can be added to a class definition. See, below.

	- Add cardinality to the collection (minimum and maximum of elements)
	but needs collaboration from the manager. Maybe it has something to do with how other metadata can be added to a class definition. See, below.

(DONE)	- Think about transactions, undo and redo and how they could be held.
	Leave it to the underlying system? how? Different kind of
	locking/transaction handling could be implemented. A nice one would
	be Optimistic Offline Lock. See Patterns Of Enterprise Application
	Architecture, Martin Fowler (2003). Addison-Wesley.

(DONE)	- It'd be nice if two (or more) different relations could be created between
	two classes. A way of dealing with that has to be thought while keeping
	everything as fast as possible.

	- Avoid the need to specify the class in some cases would be nice. For example, when asking to load an object. This is more interesting in dcop scripting. The dcop server asks for the class of the object when asking for a property. Needs: Oid, Class & Property. One solution to the problem (xess' idea!) would be to make Oid a String and store with it the classname and thus could be used by the SQL (or whatever) backend.

(PART)	- A way to create complex queries is needed. The easier approach might be to 
	implement it for sql backend only and parse the SQL. It might be done for XPath 
	queries in the XML implementation too.
	Currently there is partially working dot-notation for SQL commands. The
	query is executed to the database so you need to commit to see the latest
	objects added. Nothing extremely useful but a proof of concept.

	- Implement a SortedCollection or at least that preserves the order of insertion of objects.

	- Implement Collection as a template so it is possible to retrieve objects without casting.
	
(PART)	- Add a Signaling mechanism to allow the application to listen for "every time one/multiple property of a specific class/object is modified" 

(DONE)	- Solve problem when commit fails in the Database, and we've already set all objects and references to unmodified!
	
(DONE)	- Find a smart way to add class metainformation such as Labels, information about relations, SQL like checks for values, etc.
	
	- Create widgets to access Object classes and relations.

	- Implement an SQL backend that can read JDO XML mapping files.
	
(DONE)	- Allow to browse the properties in ClassInfo (no need to instantiate an object).
	
(DONE)	- Create a DynamicObject class and the necessary components to be able to define classes dynamically.
	
	- Make it easy to create reports, forms, etc. 
	
(DONE)	- Improve the GETOBJECT macro to be able to use multiple relations to the same class.
 
	- See if it is interesting to allow GETOBJECT use DynamicObject. That is, using load(Oid,ClassInfo), instead of load(Oid,CreateObjectFunction), or create a new load(Oid,const QString&) where the QString is the name of the class.

	- Allow an object to refer to others of the same class _correctly_.
	
	- The database structure generated by a One-To-One structure needs to be tested. And also the dot notation expander.
	
	- Changes to allow the correct generation of N-To-1 relations browseable from both sides needs to be updated to InMemorySqlBackend. (Just add a grep)

	- Update Manager QMap when the setOid function is called in an object.
	
(DONE)	- Allow to change the behaviour of the MODIFIED macro using the appropiate compile flag. Some possibilities are: 
		* Don't event mark the object as modified
		* Only mark the object as modified
		* Enable the notification mechanism
	
	- Allow different behaviours for transactions. Maybe the start() function should be added.
		* The default behaviour (without using start()) should be the already implemented optimistic offline locking.
		* If start() is called a SERIALIZABLE transaction should be started on the database until commit. This, however, means that after the start() function, the modified and unmodified objects that are kept in memory need to be reloaded (or at least selected) from the backend so that the underlying database knows the items have been read and can provide the necessary transaction protection.

	- Change the notification mechanism in the function Manager::notifyPropertyModified, so that it is easy to redefine the MODIFIED macro to use another naming scheme for matching function name with the property or even send the property name as a parameter to the MODIFIED macro.
	
	- Add missing ObjectsConstIterator and CollectionsConstIterator (the const versions for iterate the objects and collections of an object).
	
	- Create a ConstObjectRef<> template
	
	- EnsureUnderMaxObjects should test related objects too (and viceversa).
	
	- What happens when you try to remove an object that has relations? Should it be an option to cascade or not??
	
(DONE)	- Add the reset() function to Object to allow initializing all object properties??
	
(DONE)	- With SqlDbBackend save 1-1 relations to only one of the tables. This means modifying the createSchema() and load() functions. (load() of relations, of course)

	- Improve transaction support mainly with SQL backend, allowing queries to see the modifications made until the moment.
	
	- Declare Object relations in a UML style using: 
	- Define with UML naming and add the missing types of relations. e.g. aggregate, composite, etc.
	
	- Provide inheritance information in ClassInfo.
	
	- Test subclassing and resolve the problem of loading an object or a subclass manually (without the help of PostgreSQL).
	
	- Use inheritance information in ClassInfo to create inherited tables.
	
	- Allow DynamicObjects inherit from existing (dynamic or not) classes.

	- Improve enums support. Provide the list of options and whether it's a set or not. Improve enums support for ui too, creating a ComboBox when it's not a set, and a list with multiple selection when it is.


